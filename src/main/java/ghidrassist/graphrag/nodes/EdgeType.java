package ghidrassist.graphrag.nodes;

/**
 * Types of edges in the Binary Knowledge Graph.
 *
 * Edges are categorized into three groups:
 * <ul>
 *   <li>STRUCTURAL - Derived from Ghidra analysis (call graph, xrefs, hierarchy)</li>
 *   <li>SEMANTIC - Generated by LLM (similarity, logical dependencies)</li>
 *   <li>COMMUNITY - Computed by community detection algorithms</li>
 * </ul>
 */
public enum EdgeType {

    // ========================================
    // STRUCTURAL edges (from Ghidra)
    // ========================================

    /**
     * Hierarchical containment (binary → module → function → block → statement).
     * Directed from parent to child.
     */
    CONTAINS("structural", "Contains", true),

    /**
     * Function call relationship.
     * Directed from caller to callee.
     */
    CALLS("structural", "Calls", true),

    /**
     * Control flow between basic blocks.
     * Directed following execution flow.
     */
    FLOWS_TO("structural", "Flows to", true),

    /**
     * Cross-references (code referencing data or other code).
     * Directed from referencer to referenced.
     */
    REFERENCES("structural", "References", true),

    /**
     * Type/class inheritance relationships.
     * Directed from subtype to supertype.
     */
    INHERITS("structural", "Inherits from", true),

    /**
     * Data dependency - one node uses data produced by another.
     * Directed from consumer to producer.
     */
    DATA_DEPENDS("structural", "Data depends on", true),

    // ========================================
    // SEMANTIC edges (LLM-generated)
    // ========================================

    /**
     * Functions with similar semantic purpose.
     * Undirected - mutual similarity.
     */
    SIMILAR_PURPOSE("semantic", "Similar purpose to", false),

    /**
     * Logical dependency between components.
     * Directed from dependent to dependency.
     */
    DEPENDS_ON("semantic", "Depends on", true),

    /**
     * Function implements a specific concept (e.g., "authentication", "encryption").
     * Directed from function to concept node.
     */
    IMPLEMENTS("semantic", "Implements", true),

    /**
     * Related functionality without direct call relationship.
     * Undirected - mutual relationship.
     */
    RELATED_TO("semantic", "Related to", false),

    // ========================================
    // SECURITY edges (LLM-generated + analysis)
    // ========================================

    /**
     * Security relationship - potential vulnerability path.
     * Directed from source to sink in taint analysis.
     */
    VULNERABLE_VIA("security", "Vulnerable via", true),

    /**
     * Taint propagation path.
     * Directed from taint source through intermediates to sink.
     */
    TAINT_FLOWS_TO("security", "Taint flows to", true),

    /**
     * One node calls or uses a vulnerable function.
     * Directed from caller to vulnerable callee.
     */
    CALLS_VULNERABLE("security", "Calls vulnerable", true),

    // ========================================
    // COMMUNITY edges (computed)
    // ========================================

    /**
     * Node belongs to a community/module cluster.
     * Directed from node to community.
     */
    BELONGS_TO_COMMUNITY("community", "Belongs to", true),

    /**
     * Nodes that are siblings within the same community.
     * Undirected - mutual relationship.
     */
    SIBLING("community", "Sibling of", false);

    private final String category;
    private final String displayName;
    private final boolean directed;

    EdgeType(String category, String displayName, boolean directed) {
        this.category = category;
        this.displayName = displayName;
        this.directed = directed;
    }

    /**
     * Get the edge category (structural, semantic, security, community).
     */
    public String getCategory() {
        return category;
    }

    /**
     * Get the human-readable display name.
     */
    public String getDisplayName() {
        return displayName;
    }

    /**
     * Check if this edge type is directed.
     */
    public boolean isDirected() {
        return directed;
    }

    /**
     * Check if this is a structural edge derived from Ghidra.
     */
    public boolean isStructural() {
        return "structural".equals(category);
    }

    /**
     * Check if this is a semantic edge generated by LLM.
     */
    public boolean isSemantic() {
        return "semantic".equals(category);
    }

    /**
     * Check if this is a security-related edge.
     */
    public boolean isSecurity() {
        return "security".equals(category);
    }

    /**
     * Check if this is a community/clustering edge.
     */
    public boolean isCommunity() {
        return "community".equals(category);
    }

    /**
     * Parse an edge type from its string representation.
     */
    public static EdgeType fromString(String value) {
        if (value == null) {
            return null;
        }
        try {
            return valueOf(value.toUpperCase());
        } catch (IllegalArgumentException e) {
            return null;
        }
    }
}
